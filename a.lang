"Some random string!"




        '   Some(b'T') if self.match_sequence("True") => Some(self.new_token_and_advance(TokenValue::True, p..p+4)),
            Some(b'F') if self.match_sequence("False") => Some(self.new_token_and_advance(TokenValue::False, p..p+5)),
            Some(b'F') if self.match_sequence("First") => Some(self.new_token_and_advance(TokenValue::First, p..p+5)),
            Some(b'L') if self.match_sequence("Last") => Some(self.new_token_and_advance(TokenValue::Last, p..p+4)),

            Some(b'a') if self.match_sequence("and") => Some(self.new_token_and_advance(TokenValue::KeywordAnd, p..p+3)),
            Some(b'o') if self.match_sequence("or") => Some(self.new_token_and_advance(TokenValue::KeywordOr, p..p+2)),
            Some(b'n') if self.match_sequence("not") => Some(self.new_token_and_advance(TokenValue::KeywordNot, p..p+3)),

            Some(b'a') if self.match_sequence("as") => Some(self.new_token_and_advance(TokenValue::As, p..p+2)),
            Some(b'a') if self.match_sequence("assert") => Some(self.new_token_and_advance(TokenValue::Assert, p..p+6)),
            Some(b'a') if self.match_sequence("async") => Some(self.new_token_and_advance(TokenValue::Async, p..p+5)),
            Some(b'a') if self.match_sequence("await") => Some(self.new_token_and_advance(TokenValue::Await, p..p+5)),
            
            Some(b'b') if self.match_sequence("break") => Some(self.new_token_and_advance(TokenValue::Break, p..p+5)),
            
            Some(b'c') if self.match_sequence("class") => Some(self.new_token_and_advance(TokenValue::Class, p..p+5)),
            Some(b's') if self.match_sequence("struct") => Some(self.new_token_and_advance(TokenValue::Struct, p..p+6)),
            Some(b'c') if self.match_sequence("continue") => Some(self.new_token_and_advance(TokenValue::Continue, p..p+8)),
            Some(b'd') if self.match_sequence("def") => Some(self.new_token_and_advance(TokenValue::Def, p..p+3)),
            Some(b'd') if self.match_sequence("del") => Some(self.new_token_and_advance(TokenValue::Del, p..p+3)),
            Some(b'e') if self.match_sequence("elif") => Some(self.new_token_and_advance(TokenValue::Elif, p..p+4)),
    
            Some(b'e') if self.match_sequence("else") => Some(self.new_token_and_advance(TokenValue::Else, p..p+4)),
            Some(b'e') if self.match_sequence("except") => Some(self.new_token_and_advance(TokenValue::Except, p..p+6)),
            Some(b'f') if self.match_sequence("finally") => Some(self.new_token_and_advance(TokenValue::Finally, p..p+7)),
            Some(b'f') if self.match_sequence("for") => Some(self.new_token_and_advance(TokenValue::For, p..p+3)),
            Some(b'f') if self.match_sequence("from") => Some(self.new_token_and_advance(TokenValue::From, p..p+4)),
            Some(b'g') if self.match_sequence("global") => Some(self.new_token_and_advance(TokenValue::Global, p..p+6)),
            Some(b'i') if self.match_sequence("if") => Some(self.new_token_and_advance(TokenValue::If, p..p+2)),

            Some(b'i') if self.match_sequence("import") => Some(self.new_token_and_advance(TokenValue::Import, p..p+6)),
            Some(b'i') if self.match_sequence("in") => Some(self.new_token_and_advance(TokenValue::In, p..p+2)),
            Some(b'i') if self.match_sequence("is") => Some(self.new_token_and_advance(TokenValue::Is, p..p+2)),
            Some(b'l') if self.match_sequence("lambda") => Some(self.new_token_and_advance(TokenValue::Lambda, p..p+6)),
            Some(b'n') if self.match_sequence("nonlocal") => Some(self.new_token_and_advance(TokenValue::NonLocal, p..p+8)),
            
            Some(b'p') if self.match_sequence("pass") => Some(self.new_token_and_advance(TokenValue::Pass, p..p+4)),
            Some(b'r') if self.match_sequence("raise") => Some(self.new_token_and_advance(TokenValue::Raise, p..p+5)),
            Some(b'r') if self.match_sequence("return") => Some(self.new_token_and_advance(TokenValue::Return, p..p+6)),
            Some(b't') if self.match_sequence("try") => Some(self.new_token_and_advance(TokenValue::Try, p..p+3)),
            Some(b'w') if self.match_sequence("while") => Some(self.new_token_and_advance(TokenValue::While, p..p+5)),
            Some(b'w') if self.match_sequence("with") => Some(self.new_token_and_advance(TokenValue::With, p..p+4)),
            Some(b'y') if self.match_sequence("yield") => Some(self.new_token_and_advance(TokenValue::Yield, p..p+5)),




main :: ()


main :: () {
    a : int = 42


    a := size * intermediate where { 
        intermediate := 2; 
        size := b; 
    }

    func :: (b) -> int {
        intermediate := 2; 
        size := b;
        return size * intermediate;
    }


    func :: (b: int) -> int {
        return size * intermediate for { 
            intermediate := 2; 
            size := b; 
        }
    }



    func :: (a: int, b: int) -> int { return a + b; }
    func :: (a: _, b: _) => a + b;


    adder :: a, b => a + b;



    func :: (b: int) => size * intermediate for {
        intermediate := 2; 
        size := b; 
    }



    func :: (b: int) -> success: bool {
        
    }


    a := size * intermediate for { 
        intermediate := 2; 
        size := b; 
    }


    for el := ..members 
    {
        accum += it
        arr[it_index]
    }

    for it, it_index := enumerate(..members) {
    }

    for ..members for members := array {
    }




    result := if value == {
        3     => 1
        4..=5 => 2
        _     => 3
    }


    result := 1 if value == 3 else 2 



    if cond {
        ...
    } else {
        ...
    }


    if value == {
        4     => ...
        1..5  => ...
        _     => 1
    }


    {

    }


    1:4

    1..10:-2

    1..=10:-2

    if condition { 1 }
    if condition { 1 }
    else { 0 }


    if condition {
        ...
    }


    if value == {
        4 => print("Sth")   
        1..2 => print("...")
        _ => ...
    }


    a : {
        -> int64  #if debug
        -> int32  
    }


    a : #if debug=={
        1 -> int64
        _ -> int32
    } = #if debug=={
        1 => 2^60
        _ => 2^30
    }





    some_func :: (a: int) -> {
        int32 #if debug
        else int64
    } => a


    some_func :: (a: int) -> #if debug == {
        1 -> int32 
        0 -> int64
    } => a




    value = 3 if debug else 2





    if value == {
        1 => print("Hello")
        4..5
    }



    a := {
        intermediate := 2
        size := 3

        intermediate * size
    }   





    vec :: (t: T) -> bool {
        return @check_if_compiles {
            t + t
            scalar * t
            0 as t
            1 as t
        }
    }

    vec :: (t: T) -> bool { 
        @require {
            { t + t } -> T;
            { scalar * t } -> T;
            { 0 as t } -> T;
            { 1 as t } -> T;
        } else panic();
    }

    vec :: (t: T) -> u32 { 
        @require {
            t + t -> T,
            scalar * t -> T,
            0 as t -> T,
            1 as t -> T
        } else {
            return 0;
        }
    }

    vec :: (t: T) -> @require {
            { t + t } -> T;
            { scalar * t } -> T;
            { 0 as T } -> T;
            { 1 as T } -> T;
        }


    @if add_func -> T {

    }

    #if t+t -> T && scalar * T -> T && 0 as T && 

    #if t+t -> T else panic();

    if () {

    }

    @if @compiles{0 as T}

    if t + t -> T {

    }

    #if DEBUG || compile_error() {}



    if 1 e2 print();

    if 10i != 0: print()

    #if !DEBUG compile_error();

    #if 0 {

    } #else {

    }

    @if DEBUG and @if_compiles {(t+t) -> T} else panic()

    T @requires vec

    f :: (a: T/vec?, b: T) -> T {

    }

    f :: (i: ?vec) {

    }


    f :: (i: ?vec) -> u32:
        print()

    f :: (i: ?vec) -> u32 {
        print()
    }

    def f()











    operator^ :: (a, b) => a ** b

    operator%_% ::

    operator%_% :: (a)


    %_% a 





    a %_% b 


    a ^ b 


    a + ^a 

    ^int;

    ^Player;

    a = Player();
    if ^a == ^b;

    <a = <b 

    a: Player;
    b: ^Player;


    a ^= b 









    First
    1st 
    2nd 
    10th
    Last-1st 

    Last..First

    -1..0


    order(lines).first

    order(sorted(lines))






    for line in order(lines):
        match line {
            First(line) {
                ...
            }
            2nd(line) {
                ...
            }
            Last(line) {
                ...
            }
        }


    people[First..Last-4]

    4 - Last


    line0 = First(lines)




    loop: 
    for l in lines:

        if l == First(lines):
            pass


        if First(loop):
            afaw

        if Last(loop):
            awfawf

        inner:
        for l in files:
            if inner is first:
                pass



}



